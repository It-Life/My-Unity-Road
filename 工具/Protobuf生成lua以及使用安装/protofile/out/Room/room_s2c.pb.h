// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Room/room_s2c.proto

#ifndef PROTOBUF_Room_2froom_5fs2c_2eproto__INCLUDED
#define PROTOBUF_Room_2froom_5fs2c_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace room {
namespace s2c {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

class tagUserStatus;
class tagTableStatus;
class tagUserScore;
class tagUserInfo;
class CMD_GR_LogonSuccess;
class CMD_GR_LogonFailure;
class CMD_GR_ConfigServer;
class CMD_GR_RequestFailure;
class CMD_GR_UserStatus;
class CMD_GR_UserScore;
class CMD_CM_SystemMessage;
class CMD_GR_TableStatus;
class CMD_GR_S_UserChat;
class CMD_GR_S_UserExpression;
class CMD_GR_TableInfo;
class CMD_GF_GameStatus;

// ===================================================================

class tagUserStatus : public ::google::protobuf::MessageLite {
 public:
  tagUserStatus();
  virtual ~tagUserStatus();

  tagUserStatus(const tagUserStatus& from);

  inline tagUserStatus& operator=(const tagUserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const tagUserStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagUserStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagUserStatus* other);

  // implements Message ----------------------------------------------

  tagUserStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagUserStatus& from);
  void MergeFrom(const tagUserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tableId = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // required int32 chairId = 2;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairIdFieldNumber = 2;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // required int32 userStatus = 3;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 3;
  inline ::google::protobuf::int32 userstatus() const;
  inline void set_userstatus(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:room.s2c.tagUserStatus)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();

  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 chairid_;
  ::google::protobuf::int32 userstatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static tagUserStatus* default_instance_;
};
// -------------------------------------------------------------------

class tagTableStatus : public ::google::protobuf::MessageLite {
 public:
  tagTableStatus();
  virtual ~tagTableStatus();

  tagTableStatus(const tagTableStatus& from);

  inline tagTableStatus& operator=(const tagTableStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const tagTableStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagTableStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagTableStatus* other);

  // implements Message ----------------------------------------------

  tagTableStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagTableStatus& from);
  void MergeFrom(const tagTableStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tableLock = 1;
  inline bool has_tablelock() const;
  inline void clear_tablelock();
  static const int kTableLockFieldNumber = 1;
  inline ::google::protobuf::int32 tablelock() const;
  inline void set_tablelock(::google::protobuf::int32 value);

  // required int32 playStatus = 2;
  inline bool has_playstatus() const;
  inline void clear_playstatus();
  static const int kPlayStatusFieldNumber = 2;
  inline ::google::protobuf::int32 playstatus() const;
  inline void set_playstatus(::google::protobuf::int32 value);

  // required int32 cellScore = 3;
  inline bool has_cellscore() const;
  inline void clear_cellscore();
  static const int kCellScoreFieldNumber = 3;
  inline ::google::protobuf::int32 cellscore() const;
  inline void set_cellscore(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:room.s2c.tagTableStatus)
 private:
  inline void set_has_tablelock();
  inline void clear_has_tablelock();
  inline void set_has_playstatus();
  inline void clear_has_playstatus();
  inline void set_has_cellscore();
  inline void clear_has_cellscore();

  ::google::protobuf::int32 tablelock_;
  ::google::protobuf::int32 playstatus_;
  ::google::protobuf::int32 cellscore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static tagTableStatus* default_instance_;
};
// -------------------------------------------------------------------

class tagUserScore : public ::google::protobuf::MessageLite {
 public:
  tagUserScore();
  virtual ~tagUserScore();

  tagUserScore(const tagUserScore& from);

  inline tagUserScore& operator=(const tagUserScore& from) {
    CopyFrom(from);
    return *this;
  }

  static const tagUserScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagUserScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagUserScore* other);

  // implements Message ----------------------------------------------

  tagUserScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagUserScore& from);
  void MergeFrom(const tagUserScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::int64 score() const;
  inline void set_score(::google::protobuf::int64 value);

  // optional int64 grade = 2;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 2;
  inline ::google::protobuf::int64 grade() const;
  inline void set_grade(::google::protobuf::int64 value);

  // required int64 insure = 3;
  inline bool has_insure() const;
  inline void clear_insure();
  static const int kInsureFieldNumber = 3;
  inline ::google::protobuf::int64 insure() const;
  inline void set_insure(::google::protobuf::int64 value);

  // required int32 winCount = 4;
  inline bool has_wincount() const;
  inline void clear_wincount();
  static const int kWinCountFieldNumber = 4;
  inline ::google::protobuf::int32 wincount() const;
  inline void set_wincount(::google::protobuf::int32 value);

  // required int32 lostCount = 5;
  inline bool has_lostcount() const;
  inline void clear_lostcount();
  static const int kLostCountFieldNumber = 5;
  inline ::google::protobuf::int32 lostcount() const;
  inline void set_lostcount(::google::protobuf::int32 value);

  // required int32 drawCount = 6;
  inline bool has_drawcount() const;
  inline void clear_drawcount();
  static const int kDrawCountFieldNumber = 6;
  inline ::google::protobuf::int32 drawcount() const;
  inline void set_drawcount(::google::protobuf::int32 value);

  // required int32 fleeCount = 7;
  inline bool has_fleecount() const;
  inline void clear_fleecount();
  static const int kFleeCountFieldNumber = 7;
  inline ::google::protobuf::int32 fleecount() const;
  inline void set_fleecount(::google::protobuf::int32 value);

  // optional int64 integralCount = 8;
  inline bool has_integralcount() const;
  inline void clear_integralcount();
  static const int kIntegralCountFieldNumber = 8;
  inline ::google::protobuf::int64 integralcount() const;
  inline void set_integralcount(::google::protobuf::int64 value);

  // optional int64 danScore = 9;
  inline bool has_danscore() const;
  inline void clear_danscore();
  static const int kDanScoreFieldNumber = 9;
  inline ::google::protobuf::int64 danscore() const;
  inline void set_danscore(::google::protobuf::int64 value);

  // optional int32 awardFlag = 10;
  inline bool has_awardflag() const;
  inline void clear_awardflag();
  static const int kAwardFlagFieldNumber = 10;
  inline ::google::protobuf::int32 awardflag() const;
  inline void set_awardflag(::google::protobuf::int32 value);

  // optional int32 winStreak = 11;
  inline bool has_winstreak() const;
  inline void clear_winstreak();
  static const int kWinStreakFieldNumber = 11;
  inline ::google::protobuf::int32 winstreak() const;
  inline void set_winstreak(::google::protobuf::int32 value);

  // optional int32 userMedal = 12;
  inline bool has_usermedal() const;
  inline void clear_usermedal();
  static const int kUserMedalFieldNumber = 12;
  inline ::google::protobuf::int32 usermedal() const;
  inline void set_usermedal(::google::protobuf::int32 value);

  // optional int32 experience = 13;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 13;
  inline ::google::protobuf::int32 experience() const;
  inline void set_experience(::google::protobuf::int32 value);

  // optional int32 loveLiness = 14;
  inline bool has_loveliness() const;
  inline void clear_loveliness();
  static const int kLoveLinessFieldNumber = 14;
  inline ::google::protobuf::int32 loveliness() const;
  inline void set_loveliness(::google::protobuf::int32 value);

  // optional int32 memberOrder = 15;
  inline bool has_memberorder() const;
  inline void clear_memberorder();
  static const int kMemberOrderFieldNumber = 15;
  inline ::google::protobuf::int32 memberorder() const;
  inline void set_memberorder(::google::protobuf::int32 value);

  // optional int64 ticket = 16;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 16;
  inline ::google::protobuf::int64 ticket() const;
  inline void set_ticket(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:room.s2c.tagUserScore)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_insure();
  inline void clear_has_insure();
  inline void set_has_wincount();
  inline void clear_has_wincount();
  inline void set_has_lostcount();
  inline void clear_has_lostcount();
  inline void set_has_drawcount();
  inline void clear_has_drawcount();
  inline void set_has_fleecount();
  inline void clear_has_fleecount();
  inline void set_has_integralcount();
  inline void clear_has_integralcount();
  inline void set_has_danscore();
  inline void clear_has_danscore();
  inline void set_has_awardflag();
  inline void clear_has_awardflag();
  inline void set_has_winstreak();
  inline void clear_has_winstreak();
  inline void set_has_usermedal();
  inline void clear_has_usermedal();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_loveliness();
  inline void clear_has_loveliness();
  inline void set_has_memberorder();
  inline void clear_has_memberorder();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  ::google::protobuf::int64 score_;
  ::google::protobuf::int64 grade_;
  ::google::protobuf::int64 insure_;
  ::google::protobuf::int32 wincount_;
  ::google::protobuf::int32 lostcount_;
  ::google::protobuf::int32 drawcount_;
  ::google::protobuf::int32 fleecount_;
  ::google::protobuf::int64 integralcount_;
  ::google::protobuf::int64 danscore_;
  ::google::protobuf::int32 awardflag_;
  ::google::protobuf::int32 winstreak_;
  ::google::protobuf::int32 usermedal_;
  ::google::protobuf::int32 experience_;
  ::google::protobuf::int32 loveliness_;
  ::google::protobuf::int32 memberorder_;
  ::google::protobuf::int64 ticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static tagUserScore* default_instance_;
};
// -------------------------------------------------------------------

class tagUserInfo : public ::google::protobuf::MessageLite {
 public:
  tagUserInfo();
  virtual ~tagUserInfo();

  tagUserInfo(const tagUserInfo& from);

  inline tagUserInfo& operator=(const tagUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const tagUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagUserInfo* other);

  // implements Message ----------------------------------------------

  tagUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagUserInfo& from);
  void MergeFrom(const tagUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 groupId = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // optional int32 faceId = 4;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceIdFieldNumber = 4;
  inline ::google::protobuf::int32 faceid() const;
  inline void set_faceid(::google::protobuf::int32 value);

  // optional int32 customId = 5;
  inline bool has_customid() const;
  inline void clear_customid();
  static const int kCustomIdFieldNumber = 5;
  inline ::google::protobuf::int32 customid() const;
  inline void set_customid(::google::protobuf::int32 value);

  // required int32 gender = 6;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 6;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);

  // required int32 memberOrder = 7;
  inline bool has_memberorder() const;
  inline void clear_memberorder();
  static const int kMemberOrderFieldNumber = 7;
  inline ::google::protobuf::int32 memberorder() const;
  inline void set_memberorder(::google::protobuf::int32 value);

  // required int32 masterOrder = 8;
  inline bool has_masterorder() const;
  inline void clear_masterorder();
  static const int kMasterOrderFieldNumber = 8;
  inline ::google::protobuf::int32 masterorder() const;
  inline void set_masterorder(::google::protobuf::int32 value);

  // required .room.s2c.tagUserStatus userStatus = 9;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 9;
  inline const ::room::s2c::tagUserStatus& userstatus() const;
  inline ::room::s2c::tagUserStatus* mutable_userstatus();
  inline ::room::s2c::tagUserStatus* release_userstatus();
  inline void set_allocated_userstatus(::room::s2c::tagUserStatus* userstatus);

  // required .room.s2c.tagUserScore userScore = 10;
  inline bool has_userscore() const;
  inline void clear_userscore();
  static const int kUserScoreFieldNumber = 10;
  inline const ::room::s2c::tagUserScore& userscore() const;
  inline ::room::s2c::tagUserScore* mutable_userscore();
  inline ::room::s2c::tagUserScore* release_userscore();
  inline void set_allocated_userscore(::room::s2c::tagUserScore* userscore);

  // optional int32 roomCard = 11;
  inline bool has_roomcard() const;
  inline void clear_roomcard();
  static const int kRoomCardFieldNumber = 11;
  inline ::google::protobuf::int32 roomcard() const;
  inline void set_roomcard(::google::protobuf::int32 value);

  // optional int32 rechargeAmount = 12;
  inline bool has_rechargeamount() const;
  inline void clear_rechargeamount();
  static const int kRechargeAmountFieldNumber = 12;
  inline ::google::protobuf::int32 rechargeamount() const;
  inline void set_rechargeamount(::google::protobuf::int32 value);

  // optional int32 takeCount = 13;
  inline bool has_takecount() const;
  inline void clear_takecount();
  static const int kTakeCountFieldNumber = 13;
  inline ::google::protobuf::int32 takecount() const;
  inline void set_takecount(::google::protobuf::int32 value);

  // required string nickName = 14;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 14;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string groupName = 15;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 15;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional string underWrite = 16;
  inline bool has_underwrite() const;
  inline void clear_underwrite();
  static const int kUnderWriteFieldNumber = 16;
  inline const ::std::string& underwrite() const;
  inline void set_underwrite(const ::std::string& value);
  inline void set_underwrite(const char* value);
  inline void set_underwrite(const char* value, size_t size);
  inline ::std::string* mutable_underwrite();
  inline ::std::string* release_underwrite();
  inline void set_allocated_underwrite(::std::string* underwrite);

  // @@protoc_insertion_point(class_scope:room.s2c.tagUserInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_customid();
  inline void clear_has_customid();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_memberorder();
  inline void clear_has_memberorder();
  inline void set_has_masterorder();
  inline void clear_has_masterorder();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();
  inline void set_has_userscore();
  inline void clear_has_userscore();
  inline void set_has_roomcard();
  inline void clear_has_roomcard();
  inline void set_has_rechargeamount();
  inline void clear_has_rechargeamount();
  inline void set_has_takecount();
  inline void clear_has_takecount();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_underwrite();
  inline void clear_has_underwrite();

  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 groupid_;
  ::google::protobuf::int32 faceid_;
  ::google::protobuf::int32 customid_;
  ::google::protobuf::int32 gender_;
  ::google::protobuf::int32 memberorder_;
  ::google::protobuf::int32 masterorder_;
  ::room::s2c::tagUserStatus* userstatus_;
  ::room::s2c::tagUserScore* userscore_;
  ::google::protobuf::int32 roomcard_;
  ::google::protobuf::int32 rechargeamount_;
  ::std::string* nickname_;
  ::std::string* groupname_;
  ::std::string* underwrite_;
  ::google::protobuf::int32 takecount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static tagUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_LogonSuccess : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_LogonSuccess();
  virtual ~CMD_GR_LogonSuccess();

  CMD_GR_LogonSuccess(const CMD_GR_LogonSuccess& from);

  inline CMD_GR_LogonSuccess& operator=(const CMD_GR_LogonSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_LogonSuccess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_LogonSuccess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_LogonSuccess* other);

  // implements Message ----------------------------------------------

  CMD_GR_LogonSuccess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_LogonSuccess& from);
  void MergeFrom(const CMD_GR_LogonSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userRight = 1;
  inline bool has_userright() const;
  inline void clear_userright();
  static const int kUserRightFieldNumber = 1;
  inline ::google::protobuf::int32 userright() const;
  inline void set_userright(::google::protobuf::int32 value);

  // required int32 masterRight = 2;
  inline bool has_masterright() const;
  inline void clear_masterright();
  static const int kMasterRightFieldNumber = 2;
  inline ::google::protobuf::int32 masterright() const;
  inline void set_masterright(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_LogonSuccess)
 private:
  inline void set_has_userright();
  inline void clear_has_userright();
  inline void set_has_masterright();
  inline void clear_has_masterright();

  ::google::protobuf::int32 userright_;
  ::google::protobuf::int32 masterright_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_LogonSuccess* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_LogonFailure : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_LogonFailure();
  virtual ~CMD_GR_LogonFailure();

  CMD_GR_LogonFailure(const CMD_GR_LogonFailure& from);

  inline CMD_GR_LogonFailure& operator=(const CMD_GR_LogonFailure& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_LogonFailure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_LogonFailure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_LogonFailure* other);

  // implements Message ----------------------------------------------

  CMD_GR_LogonFailure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_LogonFailure& from);
  void MergeFrom(const CMD_GR_LogonFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string describeString = 2;
  inline bool has_describestring() const;
  inline void clear_describestring();
  static const int kDescribeStringFieldNumber = 2;
  inline const ::std::string& describestring() const;
  inline void set_describestring(const ::std::string& value);
  inline void set_describestring(const char* value);
  inline void set_describestring(const char* value, size_t size);
  inline ::std::string* mutable_describestring();
  inline ::std::string* release_describestring();
  inline void set_allocated_describestring(::std::string* describestring);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_LogonFailure)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_describestring();
  inline void clear_has_describestring();

  ::std::string* describestring_;
  ::google::protobuf::int32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_LogonFailure* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_ConfigServer : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_ConfigServer();
  virtual ~CMD_GR_ConfigServer();

  CMD_GR_ConfigServer(const CMD_GR_ConfigServer& from);

  inline CMD_GR_ConfigServer& operator=(const CMD_GR_ConfigServer& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_ConfigServer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_ConfigServer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_ConfigServer* other);

  // implements Message ----------------------------------------------

  CMD_GR_ConfigServer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_ConfigServer& from);
  void MergeFrom(const CMD_GR_ConfigServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tableCount = 1;
  inline bool has_tablecount() const;
  inline void clear_tablecount();
  static const int kTableCountFieldNumber = 1;
  inline ::google::protobuf::int32 tablecount() const;
  inline void set_tablecount(::google::protobuf::int32 value);

  // required int32 chairCount = 2;
  inline bool has_chaircount() const;
  inline void clear_chaircount();
  static const int kChairCountFieldNumber = 2;
  inline ::google::protobuf::int32 chaircount() const;
  inline void set_chaircount(::google::protobuf::int32 value);

  // required int32 serverType = 3;
  inline bool has_servertype() const;
  inline void clear_servertype();
  static const int kServerTypeFieldNumber = 3;
  inline ::google::protobuf::int32 servertype() const;
  inline void set_servertype(::google::protobuf::int32 value);

  // required int32 serverRule = 4;
  inline bool has_serverrule() const;
  inline void clear_serverrule();
  static const int kServerRuleFieldNumber = 4;
  inline ::google::protobuf::int32 serverrule() const;
  inline void set_serverrule(::google::protobuf::int32 value);

  // required bool setScore = 5;
  inline bool has_setscore() const;
  inline void clear_setscore();
  static const int kSetScoreFieldNumber = 5;
  inline bool setscore() const;
  inline void set_setscore(bool value);

  // optional int32 maxTimes = 6;
  inline bool has_maxtimes() const;
  inline void clear_maxtimes();
  static const int kMaxTimesFieldNumber = 6;
  inline ::google::protobuf::int32 maxtimes() const;
  inline void set_maxtimes(::google::protobuf::int32 value);

  // optional bool caijinRoom = 7;
  inline bool has_caijinroom() const;
  inline void clear_caijinroom();
  static const int kCaijinRoomFieldNumber = 7;
  inline bool caijinroom() const;
  inline void set_caijinroom(bool value);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_ConfigServer)
 private:
  inline void set_has_tablecount();
  inline void clear_has_tablecount();
  inline void set_has_chaircount();
  inline void clear_has_chaircount();
  inline void set_has_servertype();
  inline void clear_has_servertype();
  inline void set_has_serverrule();
  inline void clear_has_serverrule();
  inline void set_has_setscore();
  inline void clear_has_setscore();
  inline void set_has_maxtimes();
  inline void clear_has_maxtimes();
  inline void set_has_caijinroom();
  inline void clear_has_caijinroom();

  ::google::protobuf::int32 tablecount_;
  ::google::protobuf::int32 chaircount_;
  ::google::protobuf::int32 servertype_;
  ::google::protobuf::int32 serverrule_;
  ::google::protobuf::int32 maxtimes_;
  bool setscore_;
  bool caijinroom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_ConfigServer* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_RequestFailure : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_RequestFailure();
  virtual ~CMD_GR_RequestFailure();

  CMD_GR_RequestFailure(const CMD_GR_RequestFailure& from);

  inline CMD_GR_RequestFailure& operator=(const CMD_GR_RequestFailure& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_RequestFailure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_RequestFailure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_RequestFailure* other);

  // implements Message ----------------------------------------------

  CMD_GR_RequestFailure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_RequestFailure& from);
  void MergeFrom(const CMD_GR_RequestFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // required string describeString = 2;
  inline bool has_describestring() const;
  inline void clear_describestring();
  static const int kDescribeStringFieldNumber = 2;
  inline const ::std::string& describestring() const;
  inline void set_describestring(const ::std::string& value);
  inline void set_describestring(const char* value);
  inline void set_describestring(const char* value, size_t size);
  inline ::std::string* mutable_describestring();
  inline ::std::string* release_describestring();
  inline void set_allocated_describestring(::std::string* describestring);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_RequestFailure)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_describestring();
  inline void clear_has_describestring();

  ::std::string* describestring_;
  ::google::protobuf::int32 errorcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_RequestFailure* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_UserStatus : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_UserStatus();
  virtual ~CMD_GR_UserStatus();

  CMD_GR_UserStatus(const CMD_GR_UserStatus& from);

  inline CMD_GR_UserStatus& operator=(const CMD_GR_UserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_UserStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_UserStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_UserStatus* other);

  // implements Message ----------------------------------------------

  CMD_GR_UserStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_UserStatus& from);
  void MergeFrom(const CMD_GR_UserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required .room.s2c.tagUserStatus userStatus = 2;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 2;
  inline const ::room::s2c::tagUserStatus& userstatus() const;
  inline ::room::s2c::tagUserStatus* mutable_userstatus();
  inline ::room::s2c::tagUserStatus* release_userstatus();
  inline void set_allocated_userstatus(::room::s2c::tagUserStatus* userstatus);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_UserStatus)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();

  ::room::s2c::tagUserStatus* userstatus_;
  ::google::protobuf::int32 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_UserStatus* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_UserScore : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_UserScore();
  virtual ~CMD_GR_UserScore();

  CMD_GR_UserScore(const CMD_GR_UserScore& from);

  inline CMD_GR_UserScore& operator=(const CMD_GR_UserScore& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_UserScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_UserScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_UserScore* other);

  // implements Message ----------------------------------------------

  CMD_GR_UserScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_UserScore& from);
  void MergeFrom(const CMD_GR_UserScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required .room.s2c.tagUserScore userScore = 2;
  inline bool has_userscore() const;
  inline void clear_userscore();
  static const int kUserScoreFieldNumber = 2;
  inline const ::room::s2c::tagUserScore& userscore() const;
  inline ::room::s2c::tagUserScore* mutable_userscore();
  inline ::room::s2c::tagUserScore* release_userscore();
  inline void set_allocated_userscore(::room::s2c::tagUserScore* userscore);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_UserScore)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_userscore();
  inline void clear_has_userscore();

  ::room::s2c::tagUserScore* userscore_;
  ::google::protobuf::int32 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_UserScore* default_instance_;
};
// -------------------------------------------------------------------

class CMD_CM_SystemMessage : public ::google::protobuf::MessageLite {
 public:
  CMD_CM_SystemMessage();
  virtual ~CMD_CM_SystemMessage();

  CMD_CM_SystemMessage(const CMD_CM_SystemMessage& from);

  inline CMD_CM_SystemMessage& operator=(const CMD_CM_SystemMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_CM_SystemMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_CM_SystemMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_CM_SystemMessage* other);

  // implements Message ----------------------------------------------

  CMD_CM_SystemMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_CM_SystemMessage& from);
  void MergeFrom(const CMD_CM_SystemMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string msgContent = 2;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 2;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const char* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  inline void set_allocated_msgcontent(::std::string* msgcontent);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_CM_SystemMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();

  ::std::string* msgcontent_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_CM_SystemMessage* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_TableStatus : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_TableStatus();
  virtual ~CMD_GR_TableStatus();

  CMD_GR_TableStatus(const CMD_GR_TableStatus& from);

  inline CMD_GR_TableStatus& operator=(const CMD_GR_TableStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_TableStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_TableStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_TableStatus* other);

  // implements Message ----------------------------------------------

  CMD_GR_TableStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_TableStatus& from);
  void MergeFrom(const CMD_GR_TableStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tableId = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // required .room.s2c.tagTableStatus tableStatus = 2;
  inline bool has_tablestatus() const;
  inline void clear_tablestatus();
  static const int kTableStatusFieldNumber = 2;
  inline const ::room::s2c::tagTableStatus& tablestatus() const;
  inline ::room::s2c::tagTableStatus* mutable_tablestatus();
  inline ::room::s2c::tagTableStatus* release_tablestatus();
  inline void set_allocated_tablestatus(::room::s2c::tagTableStatus* tablestatus);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_TableStatus)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_tablestatus();
  inline void clear_has_tablestatus();

  ::room::s2c::tagTableStatus* tablestatus_;
  ::google::protobuf::int32 tableid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_TableStatus* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_S_UserChat : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_S_UserChat();
  virtual ~CMD_GR_S_UserChat();

  CMD_GR_S_UserChat(const CMD_GR_S_UserChat& from);

  inline CMD_GR_S_UserChat& operator=(const CMD_GR_S_UserChat& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_S_UserChat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_S_UserChat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_S_UserChat* other);

  // implements Message ----------------------------------------------

  CMD_GR_S_UserChat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_S_UserChat& from);
  void MergeFrom(const CMD_GR_S_UserChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 chatColor = 1;
  inline bool has_chatcolor() const;
  inline void clear_chatcolor();
  static const int kChatColorFieldNumber = 1;
  inline ::google::protobuf::int32 chatcolor() const;
  inline void set_chatcolor(::google::protobuf::int32 value);

  // required int32 sendUserID = 2;
  inline bool has_senduserid() const;
  inline void clear_senduserid();
  static const int kSendUserIDFieldNumber = 2;
  inline ::google::protobuf::int32 senduserid() const;
  inline void set_senduserid(::google::protobuf::int32 value);

  // required int32 targetUserID = 3;
  inline bool has_targetuserid() const;
  inline void clear_targetuserid();
  static const int kTargetUserIDFieldNumber = 3;
  inline ::google::protobuf::int32 targetuserid() const;
  inline void set_targetuserid(::google::protobuf::int32 value);

  // required string chatString = 4;
  inline bool has_chatstring() const;
  inline void clear_chatstring();
  static const int kChatStringFieldNumber = 4;
  inline const ::std::string& chatstring() const;
  inline void set_chatstring(const ::std::string& value);
  inline void set_chatstring(const char* value);
  inline void set_chatstring(const char* value, size_t size);
  inline ::std::string* mutable_chatstring();
  inline ::std::string* release_chatstring();
  inline void set_allocated_chatstring(::std::string* chatstring);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_S_UserChat)
 private:
  inline void set_has_chatcolor();
  inline void clear_has_chatcolor();
  inline void set_has_senduserid();
  inline void clear_has_senduserid();
  inline void set_has_targetuserid();
  inline void clear_has_targetuserid();
  inline void set_has_chatstring();
  inline void clear_has_chatstring();

  ::google::protobuf::int32 chatcolor_;
  ::google::protobuf::int32 senduserid_;
  ::std::string* chatstring_;
  ::google::protobuf::int32 targetuserid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_S_UserChat* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_S_UserExpression : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_S_UserExpression();
  virtual ~CMD_GR_S_UserExpression();

  CMD_GR_S_UserExpression(const CMD_GR_S_UserExpression& from);

  inline CMD_GR_S_UserExpression& operator=(const CMD_GR_S_UserExpression& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_S_UserExpression& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_S_UserExpression* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_S_UserExpression* other);

  // implements Message ----------------------------------------------

  CMD_GR_S_UserExpression* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_S_UserExpression& from);
  void MergeFrom(const CMD_GR_S_UserExpression& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemIndex = 1;
  inline bool has_itemindex() const;
  inline void clear_itemindex();
  static const int kItemIndexFieldNumber = 1;
  inline ::google::protobuf::int32 itemindex() const;
  inline void set_itemindex(::google::protobuf::int32 value);

  // required int32 sendUserId = 2;
  inline bool has_senduserid() const;
  inline void clear_senduserid();
  static const int kSendUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 senduserid() const;
  inline void set_senduserid(::google::protobuf::int32 value);

  // required int32 targetUserId = 3;
  inline bool has_targetuserid() const;
  inline void clear_targetuserid();
  static const int kTargetUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 targetuserid() const;
  inline void set_targetuserid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_S_UserExpression)
 private:
  inline void set_has_itemindex();
  inline void clear_has_itemindex();
  inline void set_has_senduserid();
  inline void clear_has_senduserid();
  inline void set_has_targetuserid();
  inline void clear_has_targetuserid();

  ::google::protobuf::int32 itemindex_;
  ::google::protobuf::int32 senduserid_;
  ::google::protobuf::int32 targetuserid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_S_UserExpression* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GR_TableInfo : public ::google::protobuf::MessageLite {
 public:
  CMD_GR_TableInfo();
  virtual ~CMD_GR_TableInfo();

  CMD_GR_TableInfo(const CMD_GR_TableInfo& from);

  inline CMD_GR_TableInfo& operator=(const CMD_GR_TableInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GR_TableInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GR_TableInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GR_TableInfo* other);

  // implements Message ----------------------------------------------

  CMD_GR_TableInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GR_TableInfo& from);
  void MergeFrom(const CMD_GR_TableInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .room.s2c.tagTableStatus tableStatusArray = 1;
  inline int tablestatusarray_size() const;
  inline void clear_tablestatusarray();
  static const int kTableStatusArrayFieldNumber = 1;
  inline const ::room::s2c::tagTableStatus& tablestatusarray(int index) const;
  inline ::room::s2c::tagTableStatus* mutable_tablestatusarray(int index);
  inline ::room::s2c::tagTableStatus* add_tablestatusarray();
  inline const ::google::protobuf::RepeatedPtrField< ::room::s2c::tagTableStatus >&
      tablestatusarray() const;
  inline ::google::protobuf::RepeatedPtrField< ::room::s2c::tagTableStatus >*
      mutable_tablestatusarray();

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GR_TableInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::room::s2c::tagTableStatus > tablestatusarray_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GR_TableInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMD_GF_GameStatus : public ::google::protobuf::MessageLite {
 public:
  CMD_GF_GameStatus();
  virtual ~CMD_GF_GameStatus();

  CMD_GF_GameStatus(const CMD_GF_GameStatus& from);

  inline CMD_GF_GameStatus& operator=(const CMD_GF_GameStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const CMD_GF_GameStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMD_GF_GameStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMD_GF_GameStatus* other);

  // implements Message ----------------------------------------------

  CMD_GF_GameStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMD_GF_GameStatus& from);
  void MergeFrom(const CMD_GF_GameStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameStatus = 1;
  inline bool has_gamestatus() const;
  inline void clear_gamestatus();
  static const int kGameStatusFieldNumber = 1;
  inline ::google::protobuf::int32 gamestatus() const;
  inline void set_gamestatus(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:room.s2c.CMD_GF_GameStatus)
 private:
  inline void set_has_gamestatus();
  inline void clear_has_gamestatus();

  ::google::protobuf::int32 gamestatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Room_2froom_5fs2c_2eproto();
  #endif
  friend void protobuf_AssignDesc_Room_2froom_5fs2c_2eproto();
  friend void protobuf_ShutdownFile_Room_2froom_5fs2c_2eproto();

  void InitAsDefaultInstance();
  static CMD_GF_GameStatus* default_instance_;
};
// ===================================================================


// ===================================================================

// tagUserStatus

// required int32 tableId = 1;
inline bool tagUserStatus::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagUserStatus::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagUserStatus::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagUserStatus::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 tagUserStatus::tableid() const {
  return tableid_;
}
inline void tagUserStatus::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
}

// required int32 chairId = 2;
inline bool tagUserStatus::has_chairid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagUserStatus::set_has_chairid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagUserStatus::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagUserStatus::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 tagUserStatus::chairid() const {
  return chairid_;
}
inline void tagUserStatus::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
}

// required int32 userStatus = 3;
inline bool tagUserStatus::has_userstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagUserStatus::set_has_userstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagUserStatus::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagUserStatus::clear_userstatus() {
  userstatus_ = 0;
  clear_has_userstatus();
}
inline ::google::protobuf::int32 tagUserStatus::userstatus() const {
  return userstatus_;
}
inline void tagUserStatus::set_userstatus(::google::protobuf::int32 value) {
  set_has_userstatus();
  userstatus_ = value;
}

// -------------------------------------------------------------------

// tagTableStatus

// required int32 tableLock = 1;
inline bool tagTableStatus::has_tablelock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagTableStatus::set_has_tablelock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagTableStatus::clear_has_tablelock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagTableStatus::clear_tablelock() {
  tablelock_ = 0;
  clear_has_tablelock();
}
inline ::google::protobuf::int32 tagTableStatus::tablelock() const {
  return tablelock_;
}
inline void tagTableStatus::set_tablelock(::google::protobuf::int32 value) {
  set_has_tablelock();
  tablelock_ = value;
}

// required int32 playStatus = 2;
inline bool tagTableStatus::has_playstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagTableStatus::set_has_playstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagTableStatus::clear_has_playstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagTableStatus::clear_playstatus() {
  playstatus_ = 0;
  clear_has_playstatus();
}
inline ::google::protobuf::int32 tagTableStatus::playstatus() const {
  return playstatus_;
}
inline void tagTableStatus::set_playstatus(::google::protobuf::int32 value) {
  set_has_playstatus();
  playstatus_ = value;
}

// required int32 cellScore = 3;
inline bool tagTableStatus::has_cellscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagTableStatus::set_has_cellscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagTableStatus::clear_has_cellscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagTableStatus::clear_cellscore() {
  cellscore_ = 0;
  clear_has_cellscore();
}
inline ::google::protobuf::int32 tagTableStatus::cellscore() const {
  return cellscore_;
}
inline void tagTableStatus::set_cellscore(::google::protobuf::int32 value) {
  set_has_cellscore();
  cellscore_ = value;
}

// -------------------------------------------------------------------

// tagUserScore

// required int64 score = 1;
inline bool tagUserScore::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagUserScore::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagUserScore::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagUserScore::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::int64 tagUserScore::score() const {
  return score_;
}
inline void tagUserScore::set_score(::google::protobuf::int64 value) {
  set_has_score();
  score_ = value;
}

// optional int64 grade = 2;
inline bool tagUserScore::has_grade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagUserScore::set_has_grade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagUserScore::clear_has_grade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagUserScore::clear_grade() {
  grade_ = GOOGLE_LONGLONG(0);
  clear_has_grade();
}
inline ::google::protobuf::int64 tagUserScore::grade() const {
  return grade_;
}
inline void tagUserScore::set_grade(::google::protobuf::int64 value) {
  set_has_grade();
  grade_ = value;
}

// required int64 insure = 3;
inline bool tagUserScore::has_insure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagUserScore::set_has_insure() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagUserScore::clear_has_insure() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagUserScore::clear_insure() {
  insure_ = GOOGLE_LONGLONG(0);
  clear_has_insure();
}
inline ::google::protobuf::int64 tagUserScore::insure() const {
  return insure_;
}
inline void tagUserScore::set_insure(::google::protobuf::int64 value) {
  set_has_insure();
  insure_ = value;
}

// required int32 winCount = 4;
inline bool tagUserScore::has_wincount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tagUserScore::set_has_wincount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tagUserScore::clear_has_wincount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tagUserScore::clear_wincount() {
  wincount_ = 0;
  clear_has_wincount();
}
inline ::google::protobuf::int32 tagUserScore::wincount() const {
  return wincount_;
}
inline void tagUserScore::set_wincount(::google::protobuf::int32 value) {
  set_has_wincount();
  wincount_ = value;
}

// required int32 lostCount = 5;
inline bool tagUserScore::has_lostcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tagUserScore::set_has_lostcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tagUserScore::clear_has_lostcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tagUserScore::clear_lostcount() {
  lostcount_ = 0;
  clear_has_lostcount();
}
inline ::google::protobuf::int32 tagUserScore::lostcount() const {
  return lostcount_;
}
inline void tagUserScore::set_lostcount(::google::protobuf::int32 value) {
  set_has_lostcount();
  lostcount_ = value;
}

// required int32 drawCount = 6;
inline bool tagUserScore::has_drawcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tagUserScore::set_has_drawcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tagUserScore::clear_has_drawcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tagUserScore::clear_drawcount() {
  drawcount_ = 0;
  clear_has_drawcount();
}
inline ::google::protobuf::int32 tagUserScore::drawcount() const {
  return drawcount_;
}
inline void tagUserScore::set_drawcount(::google::protobuf::int32 value) {
  set_has_drawcount();
  drawcount_ = value;
}

// required int32 fleeCount = 7;
inline bool tagUserScore::has_fleecount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tagUserScore::set_has_fleecount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tagUserScore::clear_has_fleecount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tagUserScore::clear_fleecount() {
  fleecount_ = 0;
  clear_has_fleecount();
}
inline ::google::protobuf::int32 tagUserScore::fleecount() const {
  return fleecount_;
}
inline void tagUserScore::set_fleecount(::google::protobuf::int32 value) {
  set_has_fleecount();
  fleecount_ = value;
}

// optional int64 integralCount = 8;
inline bool tagUserScore::has_integralcount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tagUserScore::set_has_integralcount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tagUserScore::clear_has_integralcount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tagUserScore::clear_integralcount() {
  integralcount_ = GOOGLE_LONGLONG(0);
  clear_has_integralcount();
}
inline ::google::protobuf::int64 tagUserScore::integralcount() const {
  return integralcount_;
}
inline void tagUserScore::set_integralcount(::google::protobuf::int64 value) {
  set_has_integralcount();
  integralcount_ = value;
}

// optional int64 danScore = 9;
inline bool tagUserScore::has_danscore() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tagUserScore::set_has_danscore() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tagUserScore::clear_has_danscore() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tagUserScore::clear_danscore() {
  danscore_ = GOOGLE_LONGLONG(0);
  clear_has_danscore();
}
inline ::google::protobuf::int64 tagUserScore::danscore() const {
  return danscore_;
}
inline void tagUserScore::set_danscore(::google::protobuf::int64 value) {
  set_has_danscore();
  danscore_ = value;
}

// optional int32 awardFlag = 10;
inline bool tagUserScore::has_awardflag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void tagUserScore::set_has_awardflag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void tagUserScore::clear_has_awardflag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void tagUserScore::clear_awardflag() {
  awardflag_ = 0;
  clear_has_awardflag();
}
inline ::google::protobuf::int32 tagUserScore::awardflag() const {
  return awardflag_;
}
inline void tagUserScore::set_awardflag(::google::protobuf::int32 value) {
  set_has_awardflag();
  awardflag_ = value;
}

// optional int32 winStreak = 11;
inline bool tagUserScore::has_winstreak() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void tagUserScore::set_has_winstreak() {
  _has_bits_[0] |= 0x00000400u;
}
inline void tagUserScore::clear_has_winstreak() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void tagUserScore::clear_winstreak() {
  winstreak_ = 0;
  clear_has_winstreak();
}
inline ::google::protobuf::int32 tagUserScore::winstreak() const {
  return winstreak_;
}
inline void tagUserScore::set_winstreak(::google::protobuf::int32 value) {
  set_has_winstreak();
  winstreak_ = value;
}

// optional int32 userMedal = 12;
inline bool tagUserScore::has_usermedal() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void tagUserScore::set_has_usermedal() {
  _has_bits_[0] |= 0x00000800u;
}
inline void tagUserScore::clear_has_usermedal() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void tagUserScore::clear_usermedal() {
  usermedal_ = 0;
  clear_has_usermedal();
}
inline ::google::protobuf::int32 tagUserScore::usermedal() const {
  return usermedal_;
}
inline void tagUserScore::set_usermedal(::google::protobuf::int32 value) {
  set_has_usermedal();
  usermedal_ = value;
}

// optional int32 experience = 13;
inline bool tagUserScore::has_experience() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void tagUserScore::set_has_experience() {
  _has_bits_[0] |= 0x00001000u;
}
inline void tagUserScore::clear_has_experience() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void tagUserScore::clear_experience() {
  experience_ = 0;
  clear_has_experience();
}
inline ::google::protobuf::int32 tagUserScore::experience() const {
  return experience_;
}
inline void tagUserScore::set_experience(::google::protobuf::int32 value) {
  set_has_experience();
  experience_ = value;
}

// optional int32 loveLiness = 14;
inline bool tagUserScore::has_loveliness() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void tagUserScore::set_has_loveliness() {
  _has_bits_[0] |= 0x00002000u;
}
inline void tagUserScore::clear_has_loveliness() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void tagUserScore::clear_loveliness() {
  loveliness_ = 0;
  clear_has_loveliness();
}
inline ::google::protobuf::int32 tagUserScore::loveliness() const {
  return loveliness_;
}
inline void tagUserScore::set_loveliness(::google::protobuf::int32 value) {
  set_has_loveliness();
  loveliness_ = value;
}

// optional int32 memberOrder = 15;
inline bool tagUserScore::has_memberorder() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void tagUserScore::set_has_memberorder() {
  _has_bits_[0] |= 0x00004000u;
}
inline void tagUserScore::clear_has_memberorder() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void tagUserScore::clear_memberorder() {
  memberorder_ = 0;
  clear_has_memberorder();
}
inline ::google::protobuf::int32 tagUserScore::memberorder() const {
  return memberorder_;
}
inline void tagUserScore::set_memberorder(::google::protobuf::int32 value) {
  set_has_memberorder();
  memberorder_ = value;
}

// optional int64 ticket = 16;
inline bool tagUserScore::has_ticket() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void tagUserScore::set_has_ticket() {
  _has_bits_[0] |= 0x00008000u;
}
inline void tagUserScore::clear_has_ticket() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void tagUserScore::clear_ticket() {
  ticket_ = GOOGLE_LONGLONG(0);
  clear_has_ticket();
}
inline ::google::protobuf::int64 tagUserScore::ticket() const {
  return ticket_;
}
inline void tagUserScore::set_ticket(::google::protobuf::int64 value) {
  set_has_ticket();
  ticket_ = value;
}

// -------------------------------------------------------------------

// tagUserInfo

// required int32 gameId = 1;
inline bool tagUserInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagUserInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagUserInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagUserInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 tagUserInfo::gameid() const {
  return gameid_;
}
inline void tagUserInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 userId = 2;
inline bool tagUserInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagUserInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagUserInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagUserInfo::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 tagUserInfo::userid() const {
  return userid_;
}
inline void tagUserInfo::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// optional int32 groupId = 3;
inline bool tagUserInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagUserInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagUserInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagUserInfo::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 tagUserInfo::groupid() const {
  return groupid_;
}
inline void tagUserInfo::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional int32 faceId = 4;
inline bool tagUserInfo::has_faceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tagUserInfo::set_has_faceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tagUserInfo::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tagUserInfo::clear_faceid() {
  faceid_ = 0;
  clear_has_faceid();
}
inline ::google::protobuf::int32 tagUserInfo::faceid() const {
  return faceid_;
}
inline void tagUserInfo::set_faceid(::google::protobuf::int32 value) {
  set_has_faceid();
  faceid_ = value;
}

// optional int32 customId = 5;
inline bool tagUserInfo::has_customid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tagUserInfo::set_has_customid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tagUserInfo::clear_has_customid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tagUserInfo::clear_customid() {
  customid_ = 0;
  clear_has_customid();
}
inline ::google::protobuf::int32 tagUserInfo::customid() const {
  return customid_;
}
inline void tagUserInfo::set_customid(::google::protobuf::int32 value) {
  set_has_customid();
  customid_ = value;
}

// required int32 gender = 6;
inline bool tagUserInfo::has_gender() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tagUserInfo::set_has_gender() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tagUserInfo::clear_has_gender() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tagUserInfo::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 tagUserInfo::gender() const {
  return gender_;
}
inline void tagUserInfo::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
}

// required int32 memberOrder = 7;
inline bool tagUserInfo::has_memberorder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tagUserInfo::set_has_memberorder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tagUserInfo::clear_has_memberorder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tagUserInfo::clear_memberorder() {
  memberorder_ = 0;
  clear_has_memberorder();
}
inline ::google::protobuf::int32 tagUserInfo::memberorder() const {
  return memberorder_;
}
inline void tagUserInfo::set_memberorder(::google::protobuf::int32 value) {
  set_has_memberorder();
  memberorder_ = value;
}

// required int32 masterOrder = 8;
inline bool tagUserInfo::has_masterorder() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tagUserInfo::set_has_masterorder() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tagUserInfo::clear_has_masterorder() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tagUserInfo::clear_masterorder() {
  masterorder_ = 0;
  clear_has_masterorder();
}
inline ::google::protobuf::int32 tagUserInfo::masterorder() const {
  return masterorder_;
}
inline void tagUserInfo::set_masterorder(::google::protobuf::int32 value) {
  set_has_masterorder();
  masterorder_ = value;
}

// required .room.s2c.tagUserStatus userStatus = 9;
inline bool tagUserInfo::has_userstatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tagUserInfo::set_has_userstatus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tagUserInfo::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tagUserInfo::clear_userstatus() {
  if (userstatus_ != NULL) userstatus_->::room::s2c::tagUserStatus::Clear();
  clear_has_userstatus();
}
inline const ::room::s2c::tagUserStatus& tagUserInfo::userstatus() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userstatus_ != NULL ? *userstatus_ : *default_instance().userstatus_;
#else
  return userstatus_ != NULL ? *userstatus_ : *default_instance_->userstatus_;
#endif
}
inline ::room::s2c::tagUserStatus* tagUserInfo::mutable_userstatus() {
  set_has_userstatus();
  if (userstatus_ == NULL) userstatus_ = new ::room::s2c::tagUserStatus;
  return userstatus_;
}
inline ::room::s2c::tagUserStatus* tagUserInfo::release_userstatus() {
  clear_has_userstatus();
  ::room::s2c::tagUserStatus* temp = userstatus_;
  userstatus_ = NULL;
  return temp;
}
inline void tagUserInfo::set_allocated_userstatus(::room::s2c::tagUserStatus* userstatus) {
  delete userstatus_;
  userstatus_ = userstatus;
  if (userstatus) {
    set_has_userstatus();
  } else {
    clear_has_userstatus();
  }
}

// required .room.s2c.tagUserScore userScore = 10;
inline bool tagUserInfo::has_userscore() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void tagUserInfo::set_has_userscore() {
  _has_bits_[0] |= 0x00000200u;
}
inline void tagUserInfo::clear_has_userscore() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void tagUserInfo::clear_userscore() {
  if (userscore_ != NULL) userscore_->::room::s2c::tagUserScore::Clear();
  clear_has_userscore();
}
inline const ::room::s2c::tagUserScore& tagUserInfo::userscore() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userscore_ != NULL ? *userscore_ : *default_instance().userscore_;
#else
  return userscore_ != NULL ? *userscore_ : *default_instance_->userscore_;
#endif
}
inline ::room::s2c::tagUserScore* tagUserInfo::mutable_userscore() {
  set_has_userscore();
  if (userscore_ == NULL) userscore_ = new ::room::s2c::tagUserScore;
  return userscore_;
}
inline ::room::s2c::tagUserScore* tagUserInfo::release_userscore() {
  clear_has_userscore();
  ::room::s2c::tagUserScore* temp = userscore_;
  userscore_ = NULL;
  return temp;
}
inline void tagUserInfo::set_allocated_userscore(::room::s2c::tagUserScore* userscore) {
  delete userscore_;
  userscore_ = userscore;
  if (userscore) {
    set_has_userscore();
  } else {
    clear_has_userscore();
  }
}

// optional int32 roomCard = 11;
inline bool tagUserInfo::has_roomcard() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void tagUserInfo::set_has_roomcard() {
  _has_bits_[0] |= 0x00000400u;
}
inline void tagUserInfo::clear_has_roomcard() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void tagUserInfo::clear_roomcard() {
  roomcard_ = 0;
  clear_has_roomcard();
}
inline ::google::protobuf::int32 tagUserInfo::roomcard() const {
  return roomcard_;
}
inline void tagUserInfo::set_roomcard(::google::protobuf::int32 value) {
  set_has_roomcard();
  roomcard_ = value;
}

// optional int32 rechargeAmount = 12;
inline bool tagUserInfo::has_rechargeamount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void tagUserInfo::set_has_rechargeamount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void tagUserInfo::clear_has_rechargeamount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void tagUserInfo::clear_rechargeamount() {
  rechargeamount_ = 0;
  clear_has_rechargeamount();
}
inline ::google::protobuf::int32 tagUserInfo::rechargeamount() const {
  return rechargeamount_;
}
inline void tagUserInfo::set_rechargeamount(::google::protobuf::int32 value) {
  set_has_rechargeamount();
  rechargeamount_ = value;
}

// optional int32 takeCount = 13;
inline bool tagUserInfo::has_takecount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void tagUserInfo::set_has_takecount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void tagUserInfo::clear_has_takecount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void tagUserInfo::clear_takecount() {
  takecount_ = 0;
  clear_has_takecount();
}
inline ::google::protobuf::int32 tagUserInfo::takecount() const {
  return takecount_;
}
inline void tagUserInfo::set_takecount(::google::protobuf::int32 value) {
  set_has_takecount();
  takecount_ = value;
}

// required string nickName = 14;
inline bool tagUserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void tagUserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00002000u;
}
inline void tagUserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void tagUserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& tagUserInfo::nickname() const {
  return *nickname_;
}
inline void tagUserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void tagUserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void tagUserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tagUserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* tagUserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tagUserInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupName = 15;
inline bool tagUserInfo::has_groupname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void tagUserInfo::set_has_groupname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void tagUserInfo::clear_has_groupname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void tagUserInfo::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& tagUserInfo::groupname() const {
  return *groupname_;
}
inline void tagUserInfo::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void tagUserInfo::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
}
inline void tagUserInfo::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tagUserInfo::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    groupname_ = new ::std::string;
  }
  return groupname_;
}
inline ::std::string* tagUserInfo::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tagUserInfo::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::kEmptyString) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underWrite = 16;
inline bool tagUserInfo::has_underwrite() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void tagUserInfo::set_has_underwrite() {
  _has_bits_[0] |= 0x00008000u;
}
inline void tagUserInfo::clear_has_underwrite() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void tagUserInfo::clear_underwrite() {
  if (underwrite_ != &::google::protobuf::internal::kEmptyString) {
    underwrite_->clear();
  }
  clear_has_underwrite();
}
inline const ::std::string& tagUserInfo::underwrite() const {
  return *underwrite_;
}
inline void tagUserInfo::set_underwrite(const ::std::string& value) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(value);
}
inline void tagUserInfo::set_underwrite(const char* value) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(value);
}
inline void tagUserInfo::set_underwrite(const char* value, size_t size) {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  underwrite_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tagUserInfo::mutable_underwrite() {
  set_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    underwrite_ = new ::std::string;
  }
  return underwrite_;
}
inline ::std::string* tagUserInfo::release_underwrite() {
  clear_has_underwrite();
  if (underwrite_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underwrite_;
    underwrite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tagUserInfo::set_allocated_underwrite(::std::string* underwrite) {
  if (underwrite_ != &::google::protobuf::internal::kEmptyString) {
    delete underwrite_;
  }
  if (underwrite) {
    set_has_underwrite();
    underwrite_ = underwrite;
  } else {
    clear_has_underwrite();
    underwrite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMD_GR_LogonSuccess

// required int32 userRight = 1;
inline bool CMD_GR_LogonSuccess::has_userright() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_LogonSuccess::set_has_userright() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_LogonSuccess::clear_has_userright() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_LogonSuccess::clear_userright() {
  userright_ = 0;
  clear_has_userright();
}
inline ::google::protobuf::int32 CMD_GR_LogonSuccess::userright() const {
  return userright_;
}
inline void CMD_GR_LogonSuccess::set_userright(::google::protobuf::int32 value) {
  set_has_userright();
  userright_ = value;
}

// required int32 masterRight = 2;
inline bool CMD_GR_LogonSuccess::has_masterright() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_LogonSuccess::set_has_masterright() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_LogonSuccess::clear_has_masterright() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_LogonSuccess::clear_masterright() {
  masterright_ = 0;
  clear_has_masterright();
}
inline ::google::protobuf::int32 CMD_GR_LogonSuccess::masterright() const {
  return masterright_;
}
inline void CMD_GR_LogonSuccess::set_masterright(::google::protobuf::int32 value) {
  set_has_masterright();
  masterright_ = value;
}

// -------------------------------------------------------------------

// CMD_GR_LogonFailure

// required int32 errorCode = 1;
inline bool CMD_GR_LogonFailure::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_LogonFailure::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_LogonFailure::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_LogonFailure::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 CMD_GR_LogonFailure::errorcode() const {
  return errorcode_;
}
inline void CMD_GR_LogonFailure::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// required string describeString = 2;
inline bool CMD_GR_LogonFailure::has_describestring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_LogonFailure::set_has_describestring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_LogonFailure::clear_has_describestring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_LogonFailure::clear_describestring() {
  if (describestring_ != &::google::protobuf::internal::kEmptyString) {
    describestring_->clear();
  }
  clear_has_describestring();
}
inline const ::std::string& CMD_GR_LogonFailure::describestring() const {
  return *describestring_;
}
inline void CMD_GR_LogonFailure::set_describestring(const ::std::string& value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
}
inline void CMD_GR_LogonFailure::set_describestring(const char* value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
}
inline void CMD_GR_LogonFailure::set_describestring(const char* value, size_t size) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD_GR_LogonFailure::mutable_describestring() {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  return describestring_;
}
inline ::std::string* CMD_GR_LogonFailure::release_describestring() {
  clear_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describestring_;
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMD_GR_LogonFailure::set_allocated_describestring(::std::string* describestring) {
  if (describestring_ != &::google::protobuf::internal::kEmptyString) {
    delete describestring_;
  }
  if (describestring) {
    set_has_describestring();
    describestring_ = describestring;
  } else {
    clear_has_describestring();
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMD_GR_ConfigServer

// required int32 tableCount = 1;
inline bool CMD_GR_ConfigServer::has_tablecount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_tablecount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_ConfigServer::clear_has_tablecount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_ConfigServer::clear_tablecount() {
  tablecount_ = 0;
  clear_has_tablecount();
}
inline ::google::protobuf::int32 CMD_GR_ConfigServer::tablecount() const {
  return tablecount_;
}
inline void CMD_GR_ConfigServer::set_tablecount(::google::protobuf::int32 value) {
  set_has_tablecount();
  tablecount_ = value;
}

// required int32 chairCount = 2;
inline bool CMD_GR_ConfigServer::has_chaircount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_chaircount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_ConfigServer::clear_has_chaircount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_ConfigServer::clear_chaircount() {
  chaircount_ = 0;
  clear_has_chaircount();
}
inline ::google::protobuf::int32 CMD_GR_ConfigServer::chaircount() const {
  return chaircount_;
}
inline void CMD_GR_ConfigServer::set_chaircount(::google::protobuf::int32 value) {
  set_has_chaircount();
  chaircount_ = value;
}

// required int32 serverType = 3;
inline bool CMD_GR_ConfigServer::has_servertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_servertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD_GR_ConfigServer::clear_has_servertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD_GR_ConfigServer::clear_servertype() {
  servertype_ = 0;
  clear_has_servertype();
}
inline ::google::protobuf::int32 CMD_GR_ConfigServer::servertype() const {
  return servertype_;
}
inline void CMD_GR_ConfigServer::set_servertype(::google::protobuf::int32 value) {
  set_has_servertype();
  servertype_ = value;
}

// required int32 serverRule = 4;
inline bool CMD_GR_ConfigServer::has_serverrule() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_serverrule() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMD_GR_ConfigServer::clear_has_serverrule() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMD_GR_ConfigServer::clear_serverrule() {
  serverrule_ = 0;
  clear_has_serverrule();
}
inline ::google::protobuf::int32 CMD_GR_ConfigServer::serverrule() const {
  return serverrule_;
}
inline void CMD_GR_ConfigServer::set_serverrule(::google::protobuf::int32 value) {
  set_has_serverrule();
  serverrule_ = value;
}

// required bool setScore = 5;
inline bool CMD_GR_ConfigServer::has_setscore() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_setscore() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMD_GR_ConfigServer::clear_has_setscore() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMD_GR_ConfigServer::clear_setscore() {
  setscore_ = false;
  clear_has_setscore();
}
inline bool CMD_GR_ConfigServer::setscore() const {
  return setscore_;
}
inline void CMD_GR_ConfigServer::set_setscore(bool value) {
  set_has_setscore();
  setscore_ = value;
}

// optional int32 maxTimes = 6;
inline bool CMD_GR_ConfigServer::has_maxtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_maxtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMD_GR_ConfigServer::clear_has_maxtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMD_GR_ConfigServer::clear_maxtimes() {
  maxtimes_ = 0;
  clear_has_maxtimes();
}
inline ::google::protobuf::int32 CMD_GR_ConfigServer::maxtimes() const {
  return maxtimes_;
}
inline void CMD_GR_ConfigServer::set_maxtimes(::google::protobuf::int32 value) {
  set_has_maxtimes();
  maxtimes_ = value;
}

// optional bool caijinRoom = 7;
inline bool CMD_GR_ConfigServer::has_caijinroom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMD_GR_ConfigServer::set_has_caijinroom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMD_GR_ConfigServer::clear_has_caijinroom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMD_GR_ConfigServer::clear_caijinroom() {
  caijinroom_ = false;
  clear_has_caijinroom();
}
inline bool CMD_GR_ConfigServer::caijinroom() const {
  return caijinroom_;
}
inline void CMD_GR_ConfigServer::set_caijinroom(bool value) {
  set_has_caijinroom();
  caijinroom_ = value;
}

// -------------------------------------------------------------------

// CMD_GR_RequestFailure

// required int32 errorCode = 1;
inline bool CMD_GR_RequestFailure::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_RequestFailure::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_RequestFailure::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_RequestFailure::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 CMD_GR_RequestFailure::errorcode() const {
  return errorcode_;
}
inline void CMD_GR_RequestFailure::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// required string describeString = 2;
inline bool CMD_GR_RequestFailure::has_describestring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_RequestFailure::set_has_describestring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_RequestFailure::clear_has_describestring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_RequestFailure::clear_describestring() {
  if (describestring_ != &::google::protobuf::internal::kEmptyString) {
    describestring_->clear();
  }
  clear_has_describestring();
}
inline const ::std::string& CMD_GR_RequestFailure::describestring() const {
  return *describestring_;
}
inline void CMD_GR_RequestFailure::set_describestring(const ::std::string& value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
}
inline void CMD_GR_RequestFailure::set_describestring(const char* value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
}
inline void CMD_GR_RequestFailure::set_describestring(const char* value, size_t size) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD_GR_RequestFailure::mutable_describestring() {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    describestring_ = new ::std::string;
  }
  return describestring_;
}
inline ::std::string* CMD_GR_RequestFailure::release_describestring() {
  clear_has_describestring();
  if (describestring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = describestring_;
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMD_GR_RequestFailure::set_allocated_describestring(::std::string* describestring) {
  if (describestring_ != &::google::protobuf::internal::kEmptyString) {
    delete describestring_;
  }
  if (describestring) {
    set_has_describestring();
    describestring_ = describestring;
  } else {
    clear_has_describestring();
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMD_GR_UserStatus

// required int32 userId = 1;
inline bool CMD_GR_UserStatus::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_UserStatus::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_UserStatus::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_UserStatus::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 CMD_GR_UserStatus::userid() const {
  return userid_;
}
inline void CMD_GR_UserStatus::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// required .room.s2c.tagUserStatus userStatus = 2;
inline bool CMD_GR_UserStatus::has_userstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_UserStatus::set_has_userstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_UserStatus::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_UserStatus::clear_userstatus() {
  if (userstatus_ != NULL) userstatus_->::room::s2c::tagUserStatus::Clear();
  clear_has_userstatus();
}
inline const ::room::s2c::tagUserStatus& CMD_GR_UserStatus::userstatus() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userstatus_ != NULL ? *userstatus_ : *default_instance().userstatus_;
#else
  return userstatus_ != NULL ? *userstatus_ : *default_instance_->userstatus_;
#endif
}
inline ::room::s2c::tagUserStatus* CMD_GR_UserStatus::mutable_userstatus() {
  set_has_userstatus();
  if (userstatus_ == NULL) userstatus_ = new ::room::s2c::tagUserStatus;
  return userstatus_;
}
inline ::room::s2c::tagUserStatus* CMD_GR_UserStatus::release_userstatus() {
  clear_has_userstatus();
  ::room::s2c::tagUserStatus* temp = userstatus_;
  userstatus_ = NULL;
  return temp;
}
inline void CMD_GR_UserStatus::set_allocated_userstatus(::room::s2c::tagUserStatus* userstatus) {
  delete userstatus_;
  userstatus_ = userstatus;
  if (userstatus) {
    set_has_userstatus();
  } else {
    clear_has_userstatus();
  }
}

// -------------------------------------------------------------------

// CMD_GR_UserScore

// required int32 userId = 1;
inline bool CMD_GR_UserScore::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_UserScore::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_UserScore::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_UserScore::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 CMD_GR_UserScore::userid() const {
  return userid_;
}
inline void CMD_GR_UserScore::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// required .room.s2c.tagUserScore userScore = 2;
inline bool CMD_GR_UserScore::has_userscore() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_UserScore::set_has_userscore() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_UserScore::clear_has_userscore() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_UserScore::clear_userscore() {
  if (userscore_ != NULL) userscore_->::room::s2c::tagUserScore::Clear();
  clear_has_userscore();
}
inline const ::room::s2c::tagUserScore& CMD_GR_UserScore::userscore() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userscore_ != NULL ? *userscore_ : *default_instance().userscore_;
#else
  return userscore_ != NULL ? *userscore_ : *default_instance_->userscore_;
#endif
}
inline ::room::s2c::tagUserScore* CMD_GR_UserScore::mutable_userscore() {
  set_has_userscore();
  if (userscore_ == NULL) userscore_ = new ::room::s2c::tagUserScore;
  return userscore_;
}
inline ::room::s2c::tagUserScore* CMD_GR_UserScore::release_userscore() {
  clear_has_userscore();
  ::room::s2c::tagUserScore* temp = userscore_;
  userscore_ = NULL;
  return temp;
}
inline void CMD_GR_UserScore::set_allocated_userscore(::room::s2c::tagUserScore* userscore) {
  delete userscore_;
  userscore_ = userscore;
  if (userscore) {
    set_has_userscore();
  } else {
    clear_has_userscore();
  }
}

// -------------------------------------------------------------------

// CMD_CM_SystemMessage

// required int32 type = 1;
inline bool CMD_CM_SystemMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_CM_SystemMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_CM_SystemMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_CM_SystemMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CMD_CM_SystemMessage::type() const {
  return type_;
}
inline void CMD_CM_SystemMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string msgContent = 2;
inline bool CMD_CM_SystemMessage::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_CM_SystemMessage::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_CM_SystemMessage::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_CM_SystemMessage::clear_msgcontent() {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& CMD_CM_SystemMessage::msgcontent() const {
  return *msgcontent_;
}
inline void CMD_CM_SystemMessage::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CMD_CM_SystemMessage::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CMD_CM_SystemMessage::set_msgcontent(const char* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD_CM_SystemMessage::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  return msgcontent_;
}
inline ::std::string* CMD_CM_SystemMessage::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMD_CM_SystemMessage::set_allocated_msgcontent(::std::string* msgcontent) {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcontent_;
  }
  if (msgcontent) {
    set_has_msgcontent();
    msgcontent_ = msgcontent;
  } else {
    clear_has_msgcontent();
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMD_GR_TableStatus

// required int32 tableId = 1;
inline bool CMD_GR_TableStatus::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_TableStatus::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_TableStatus::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_TableStatus::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 CMD_GR_TableStatus::tableid() const {
  return tableid_;
}
inline void CMD_GR_TableStatus::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
}

// required .room.s2c.tagTableStatus tableStatus = 2;
inline bool CMD_GR_TableStatus::has_tablestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_TableStatus::set_has_tablestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_TableStatus::clear_has_tablestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_TableStatus::clear_tablestatus() {
  if (tablestatus_ != NULL) tablestatus_->::room::s2c::tagTableStatus::Clear();
  clear_has_tablestatus();
}
inline const ::room::s2c::tagTableStatus& CMD_GR_TableStatus::tablestatus() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tablestatus_ != NULL ? *tablestatus_ : *default_instance().tablestatus_;
#else
  return tablestatus_ != NULL ? *tablestatus_ : *default_instance_->tablestatus_;
#endif
}
inline ::room::s2c::tagTableStatus* CMD_GR_TableStatus::mutable_tablestatus() {
  set_has_tablestatus();
  if (tablestatus_ == NULL) tablestatus_ = new ::room::s2c::tagTableStatus;
  return tablestatus_;
}
inline ::room::s2c::tagTableStatus* CMD_GR_TableStatus::release_tablestatus() {
  clear_has_tablestatus();
  ::room::s2c::tagTableStatus* temp = tablestatus_;
  tablestatus_ = NULL;
  return temp;
}
inline void CMD_GR_TableStatus::set_allocated_tablestatus(::room::s2c::tagTableStatus* tablestatus) {
  delete tablestatus_;
  tablestatus_ = tablestatus;
  if (tablestatus) {
    set_has_tablestatus();
  } else {
    clear_has_tablestatus();
  }
}

// -------------------------------------------------------------------

// CMD_GR_S_UserChat

// required int32 chatColor = 1;
inline bool CMD_GR_S_UserChat::has_chatcolor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_S_UserChat::set_has_chatcolor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_S_UserChat::clear_has_chatcolor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_S_UserChat::clear_chatcolor() {
  chatcolor_ = 0;
  clear_has_chatcolor();
}
inline ::google::protobuf::int32 CMD_GR_S_UserChat::chatcolor() const {
  return chatcolor_;
}
inline void CMD_GR_S_UserChat::set_chatcolor(::google::protobuf::int32 value) {
  set_has_chatcolor();
  chatcolor_ = value;
}

// required int32 sendUserID = 2;
inline bool CMD_GR_S_UserChat::has_senduserid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_S_UserChat::set_has_senduserid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_S_UserChat::clear_has_senduserid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_S_UserChat::clear_senduserid() {
  senduserid_ = 0;
  clear_has_senduserid();
}
inline ::google::protobuf::int32 CMD_GR_S_UserChat::senduserid() const {
  return senduserid_;
}
inline void CMD_GR_S_UserChat::set_senduserid(::google::protobuf::int32 value) {
  set_has_senduserid();
  senduserid_ = value;
}

// required int32 targetUserID = 3;
inline bool CMD_GR_S_UserChat::has_targetuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD_GR_S_UserChat::set_has_targetuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD_GR_S_UserChat::clear_has_targetuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD_GR_S_UserChat::clear_targetuserid() {
  targetuserid_ = 0;
  clear_has_targetuserid();
}
inline ::google::protobuf::int32 CMD_GR_S_UserChat::targetuserid() const {
  return targetuserid_;
}
inline void CMD_GR_S_UserChat::set_targetuserid(::google::protobuf::int32 value) {
  set_has_targetuserid();
  targetuserid_ = value;
}

// required string chatString = 4;
inline bool CMD_GR_S_UserChat::has_chatstring() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMD_GR_S_UserChat::set_has_chatstring() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMD_GR_S_UserChat::clear_has_chatstring() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMD_GR_S_UserChat::clear_chatstring() {
  if (chatstring_ != &::google::protobuf::internal::kEmptyString) {
    chatstring_->clear();
  }
  clear_has_chatstring();
}
inline const ::std::string& CMD_GR_S_UserChat::chatstring() const {
  return *chatstring_;
}
inline void CMD_GR_S_UserChat::set_chatstring(const ::std::string& value) {
  set_has_chatstring();
  if (chatstring_ == &::google::protobuf::internal::kEmptyString) {
    chatstring_ = new ::std::string;
  }
  chatstring_->assign(value);
}
inline void CMD_GR_S_UserChat::set_chatstring(const char* value) {
  set_has_chatstring();
  if (chatstring_ == &::google::protobuf::internal::kEmptyString) {
    chatstring_ = new ::std::string;
  }
  chatstring_->assign(value);
}
inline void CMD_GR_S_UserChat::set_chatstring(const char* value, size_t size) {
  set_has_chatstring();
  if (chatstring_ == &::google::protobuf::internal::kEmptyString) {
    chatstring_ = new ::std::string;
  }
  chatstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD_GR_S_UserChat::mutable_chatstring() {
  set_has_chatstring();
  if (chatstring_ == &::google::protobuf::internal::kEmptyString) {
    chatstring_ = new ::std::string;
  }
  return chatstring_;
}
inline ::std::string* CMD_GR_S_UserChat::release_chatstring() {
  clear_has_chatstring();
  if (chatstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chatstring_;
    chatstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMD_GR_S_UserChat::set_allocated_chatstring(::std::string* chatstring) {
  if (chatstring_ != &::google::protobuf::internal::kEmptyString) {
    delete chatstring_;
  }
  if (chatstring) {
    set_has_chatstring();
    chatstring_ = chatstring;
  } else {
    clear_has_chatstring();
    chatstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMD_GR_S_UserExpression

// required int32 itemIndex = 1;
inline bool CMD_GR_S_UserExpression::has_itemindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GR_S_UserExpression::set_has_itemindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GR_S_UserExpression::clear_has_itemindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GR_S_UserExpression::clear_itemindex() {
  itemindex_ = 0;
  clear_has_itemindex();
}
inline ::google::protobuf::int32 CMD_GR_S_UserExpression::itemindex() const {
  return itemindex_;
}
inline void CMD_GR_S_UserExpression::set_itemindex(::google::protobuf::int32 value) {
  set_has_itemindex();
  itemindex_ = value;
}

// required int32 sendUserId = 2;
inline bool CMD_GR_S_UserExpression::has_senduserid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMD_GR_S_UserExpression::set_has_senduserid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMD_GR_S_UserExpression::clear_has_senduserid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMD_GR_S_UserExpression::clear_senduserid() {
  senduserid_ = 0;
  clear_has_senduserid();
}
inline ::google::protobuf::int32 CMD_GR_S_UserExpression::senduserid() const {
  return senduserid_;
}
inline void CMD_GR_S_UserExpression::set_senduserid(::google::protobuf::int32 value) {
  set_has_senduserid();
  senduserid_ = value;
}

// required int32 targetUserId = 3;
inline bool CMD_GR_S_UserExpression::has_targetuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMD_GR_S_UserExpression::set_has_targetuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMD_GR_S_UserExpression::clear_has_targetuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMD_GR_S_UserExpression::clear_targetuserid() {
  targetuserid_ = 0;
  clear_has_targetuserid();
}
inline ::google::protobuf::int32 CMD_GR_S_UserExpression::targetuserid() const {
  return targetuserid_;
}
inline void CMD_GR_S_UserExpression::set_targetuserid(::google::protobuf::int32 value) {
  set_has_targetuserid();
  targetuserid_ = value;
}

// -------------------------------------------------------------------

// CMD_GR_TableInfo

// repeated .room.s2c.tagTableStatus tableStatusArray = 1;
inline int CMD_GR_TableInfo::tablestatusarray_size() const {
  return tablestatusarray_.size();
}
inline void CMD_GR_TableInfo::clear_tablestatusarray() {
  tablestatusarray_.Clear();
}
inline const ::room::s2c::tagTableStatus& CMD_GR_TableInfo::tablestatusarray(int index) const {
  return tablestatusarray_.Get(index);
}
inline ::room::s2c::tagTableStatus* CMD_GR_TableInfo::mutable_tablestatusarray(int index) {
  return tablestatusarray_.Mutable(index);
}
inline ::room::s2c::tagTableStatus* CMD_GR_TableInfo::add_tablestatusarray() {
  return tablestatusarray_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::room::s2c::tagTableStatus >&
CMD_GR_TableInfo::tablestatusarray() const {
  return tablestatusarray_;
}
inline ::google::protobuf::RepeatedPtrField< ::room::s2c::tagTableStatus >*
CMD_GR_TableInfo::mutable_tablestatusarray() {
  return &tablestatusarray_;
}

// -------------------------------------------------------------------

// CMD_GF_GameStatus

// required int32 gameStatus = 1;
inline bool CMD_GF_GameStatus::has_gamestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD_GF_GameStatus::set_has_gamestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD_GF_GameStatus::clear_has_gamestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD_GF_GameStatus::clear_gamestatus() {
  gamestatus_ = 0;
  clear_has_gamestatus();
}
inline ::google::protobuf::int32 CMD_GF_GameStatus::gamestatus() const {
  return gamestatus_;
}
inline void CMD_GF_GameStatus::set_gamestatus(::google::protobuf::int32 value) {
  set_has_gamestatus();
  gamestatus_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace s2c
}  // namespace room

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Room_2froom_5fs2c_2eproto__INCLUDED
